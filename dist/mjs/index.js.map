{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["interface Headers {\n  headerText: string;\n  children: Headers[];\n}\n\ntype ContentType = \"md\" | \"html\";\n\nconst getHeadersFromHTML = (html: string) => {\n  const headerRegex = /<h[1-6][^>]*>[\\s\\S]*?<\\/h[1-6]>/g;\n  const headers = html.match(headerRegex);\n  return headers;\n};\n\nconst getHeadersFromMarkdown = (markdown: string) => {\n  // load markdown\n  const headerRegex = /#{1,6}.*\\n/g;\n  const headers = markdown.match(headerRegex);\n\n  return headers;\n};\n\n// get headers from html, or markdown\nconst inputHeaders = (source: string, type: ContentType) => {\n  if (type === \"md\") {\n    return getHeadersFromMarkdown(source);\n  }\n  if (type === \"html\") {\n    return getHeadersFromHTML(source);\n  }\n};\n\nexport const parseHeaders = (source: string, type: ContentType): Headers[] => {\n  // get all headers\n  const htmlHeaders = inputHeaders(source, type);\n\n  if (!htmlHeaders || !htmlHeaders.length) {\n    return [];\n  }\n\n  // nest headers\n  const headers: Headers[] | undefined = [];\n  let currentHeader: Headers[] | undefined = headers;\n  let currentLevel = 0;\n  if (type === \"md\") {\n    currentLevel = htmlHeaders[0].split(\"#\").length - 1;\n  } else {\n    currentLevel = parseInt(htmlHeaders[0].charAt(2));\n  }\n\n  for (const header of htmlHeaders) {\n    let headerLevel: number;\n    let headerText: string;\n\n    if (type === \"md\") {\n      headerLevel = header.split(\"#\").length - 1;\n    } else {\n      headerLevel = parseInt(header.charAt(2));\n    }\n\n    if (type === \"md\") {\n      headerText = header\n        .replace(/#{1,6}/g, \"\")\n        .replace(/\\n/g, \"\")\n        .replace(/ {2}/g, \" \")\n        .trim();\n    } else {\n      headerText = header\n        .replace(/<[^>]*>/g, \"\")\n        .trim()\n        .replace(/\\n\\s*/g, \" \")\n        .replace(/ {2}/g, \" \");\n    }\n\n    // console.log(headerText, headerLevel);\n    if (headerLevel === currentLevel && currentHeader) {\n      currentHeader.push({ headerText: headerText, children: [] });\n    } else if (headerLevel > currentLevel && currentHeader) {\n      currentHeader[currentHeader.length - 1].children = [\n        { headerText, children: [] },\n      ];\n      currentHeader = currentHeader[currentHeader.length - 1].children;\n      currentLevel = headerLevel;\n    } else if (headerLevel < currentLevel) {\n      currentHeader = headers;\n      for (let i = 1; i < headerLevel; i++) {\n        currentHeader = currentHeader[currentHeader.length - 1].children;\n      }\n      currentLevel = headerLevel;\n      currentHeader.push({ headerText: headerText, children: [] });\n    }\n  }\n  return headers;\n};\n\n// convert nested array to html list\nexport const nestedArrayToHtmlList = (headers: Headers[]) => {\n  let html = \"<ul>\";\n\n  for (const header of headers) {\n    let id = header.headerText\n      .replace(/\\s/g, \"-\")\n      .replace(/\\:/g, \"\")\n      .toLowerCase();\n\n    html += `<li><a href=#${id}>${header.headerText}</a>`;\n\n    if (\n      typeof header !== \"undefined\" &&\n      header.children &&\n      header.children.length\n    ) {\n      html += nestedArrayToHtmlList(header.children);\n    }\n\n    html += \"</li>\";\n  }\n\n  html += \"</ul>\";\n\n  return html;\n};\n\n// export final function\nexport default (source: string, type: ContentType) => {\n  const headers = parseHeaders(source, type);\n  return nestedArrayToHtmlList(headers);\n};\n"],
  "mappings": ";AAOA,IAAM,qBAAqB,CAAC,SAAiB;AAC3C,QAAM,cAAc;AACpB,QAAM,UAAU,KAAK,MAAM,WAAW;AACtC,SAAO;AACT;AAEA,IAAM,yBAAyB,CAAC,aAAqB;AAEnD,QAAM,cAAc;AACpB,QAAM,UAAU,SAAS,MAAM,WAAW;AAE1C,SAAO;AACT;AAGA,IAAM,eAAe,CAAC,QAAgB,SAAsB;AAC1D,MAAI,SAAS,MAAM;AACjB,WAAO,uBAAuB,MAAM;AAAA,EACtC;AACA,MAAI,SAAS,QAAQ;AACnB,WAAO,mBAAmB,MAAM;AAAA,EAClC;AACF;AAEO,IAAM,eAAe,CAAC,QAAgB,SAAiC;AAE5E,QAAM,cAAc,aAAa,QAAQ,IAAI;AAE7C,MAAI,CAAC,eAAe,CAAC,YAAY,QAAQ;AACvC,WAAO,CAAC;AAAA,EACV;AAGA,QAAM,UAAiC,CAAC;AACxC,MAAI,gBAAuC;AAC3C,MAAI,eAAe;AACnB,MAAI,SAAS,MAAM;AACjB,mBAAe,YAAY,CAAC,EAAE,MAAM,GAAG,EAAE,SAAS;AAAA,EACpD,OAAO;AACL,mBAAe,SAAS,YAAY,CAAC,EAAE,OAAO,CAAC,CAAC;AAAA,EAClD;AAEA,aAAW,UAAU,aAAa;AAChC,QAAI;AACJ,QAAI;AAEJ,QAAI,SAAS,MAAM;AACjB,oBAAc,OAAO,MAAM,GAAG,EAAE,SAAS;AAAA,IAC3C,OAAO;AACL,oBAAc,SAAS,OAAO,OAAO,CAAC,CAAC;AAAA,IACzC;AAEA,QAAI,SAAS,MAAM;AACjB,mBAAa,OACV,QAAQ,WAAW,EAAE,EACrB,QAAQ,OAAO,EAAE,EACjB,QAAQ,SAAS,GAAG,EACpB,KAAK;AAAA,IACV,OAAO;AACL,mBAAa,OACV,QAAQ,YAAY,EAAE,EACtB,KAAK,EACL,QAAQ,UAAU,GAAG,EACrB,QAAQ,SAAS,GAAG;AAAA,IACzB;AAGA,QAAI,gBAAgB,gBAAgB,eAAe;AACjD,oBAAc,KAAK,EAAE,YAAwB,UAAU,CAAC,EAAE,CAAC;AAAA,IAC7D,WAAW,cAAc,gBAAgB,eAAe;AACtD,oBAAc,cAAc,SAAS,CAAC,EAAE,WAAW;AAAA,QACjD,EAAE,YAAY,UAAU,CAAC,EAAE;AAAA,MAC7B;AACA,sBAAgB,cAAc,cAAc,SAAS,CAAC,EAAE;AACxD,qBAAe;AAAA,IACjB,WAAW,cAAc,cAAc;AACrC,sBAAgB;AAChB,eAAS,IAAI,GAAG,IAAI,aAAa,KAAK;AACpC,wBAAgB,cAAc,cAAc,SAAS,CAAC,EAAE;AAAA,MAC1D;AACA,qBAAe;AACf,oBAAc,KAAK,EAAE,YAAwB,UAAU,CAAC,EAAE,CAAC;AAAA,IAC7D;AAAA,EACF;AACA,SAAO;AACT;AAGO,IAAM,wBAAwB,CAAC,YAAuB;AAC3D,MAAI,OAAO;AAEX,aAAW,UAAU,SAAS;AAC5B,QAAI,KAAK,OAAO,WACb,QAAQ,OAAO,GAAG,EAClB,QAAQ,OAAO,EAAE,EACjB,YAAY;AAEf,YAAQ,gBAAgB,EAAE,IAAI,OAAO,UAAU;AAE/C,QACE,OAAO,WAAW,eAClB,OAAO,YACP,OAAO,SAAS,QAChB;AACA,cAAQ,sBAAsB,OAAO,QAAQ;AAAA,IAC/C;AAEA,YAAQ;AAAA,EACV;AAEA,UAAQ;AAER,SAAO;AACT;AAGA,IAAO,cAAQ,CAAC,QAAgB,SAAsB;AACpD,QAAM,UAAU,aAAa,QAAQ,IAAI;AACzC,SAAO,sBAAsB,OAAO;AACtC;",
  "names": []
}
