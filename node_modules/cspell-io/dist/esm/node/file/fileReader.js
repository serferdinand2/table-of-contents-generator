// cSpell:ignore curr
// cSpell:words zlib iconv
import * as fs from 'fs';
import * as Stream from 'stream';
import { fileURLToPath } from 'url';
import { promisify } from 'util';
import * as zlib from 'zlib';
import { decode } from '../../common/encode-decode.js';
import { createDecoderTransformer } from '../../common/transformers.js';
import { fetch } from './fetch.js';
import { FetchUrlError } from './FetchError.js';
import { isFileURL, isSupportedURL, isZipped, toURL } from './util.js';
const defaultEncoding = 'utf8';
const pipeline = promisify(Stream.pipeline);
export async function readFileText(filename, encoding) {
    const url = toURL(filename);
    if (!isSupportedURL(url)) {
        throw new Error('Unsupported network protocol');
    }
    return isFileURL(url) ? _readFileText(url, encoding) : _fetchTextFromURL(url, encoding);
}
function _readFileText(url, encoding) {
    // Convert it to a string because Yarn2 cannot handle URLs.
    const filename = fileURLToPath(url);
    return _readText(() => fs.createReadStream(filename), isZipped(filename), encoding);
}
async function _fetchTextFromURL(url, encoding) {
    const response = await fetch(url);
    if (!response.ok) {
        throw FetchUrlError.create(url, response.status);
    }
    return _readText(() => response.body, isZipped(url), encoding);
}
async function _readText(getStream, isZipped, encoding) {
    const stream = getStream();
    const decoder = createDecoderTransformer(encoding);
    const collector = createTextCollector(encoding || defaultEncoding);
    return isZipped ? pipeline(stream, zlib.createGunzip(), decoder, collector) : pipeline(stream, decoder, collector);
}
export function readFileTextSync(filename, encoding) {
    const rawData = fs.readFileSync(filename);
    const data = isZipped(filename) ? zlib.gunzipSync(rawData) : rawData;
    return !encoding || encoding.startsWith('utf')
        ? decode(data)
        : encoding === 'utf16be'
            ? data.swap16().toString('utf16le')
            : data.toString(encoding);
}
function createTextCollector(encoding) {
    async function collect(iterable) {
        const buf = [];
        for await (const sb of iterable) {
            buf.push(typeof sb === 'string'
                ? sb
                : encoding === 'utf16be'
                    ? sb.swap16().toString('utf16le')
                    : sb.toString(encoding));
        }
        return buf.join('');
    }
    return collect;
}
