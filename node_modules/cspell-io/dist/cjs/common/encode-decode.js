"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcEncodingFromBom = exports.encodeUtf16BE = exports.encodeUtf16LE = exports.encodeString = exports.swapBytes = exports.swapBytesInPlace = exports.decode = exports.decodeUtf16BE = exports.decodeUtf16LE = void 0;
const arrayBuffers_js_1 = require("./arrayBuffers.js");
const BOM_BE = 0xfeff;
const BOM_LE = 0xfffe;
function decodeUtf16LE(data) {
    let buf = (0, arrayBuffers_js_1.arrayBufferViewToBuffer)(data);
    const bom = (buf[0] << 8) | buf[1];
    buf = bom === BOM_LE ? buf.subarray(2) : buf;
    return buf.toString('utf16le');
}
exports.decodeUtf16LE = decodeUtf16LE;
function decodeUtf16BE(buf) {
    return decodeUtf16LE(swapBytes(buf));
}
exports.decodeUtf16BE = decodeUtf16BE;
function decode(data, encoding) {
    const buf = (0, arrayBuffers_js_1.arrayBufferViewToBuffer)(data);
    switch (encoding) {
        case 'utf16be':
            return decodeUtf16BE(buf);
        case 'utf16le':
            return decodeUtf16LE(buf);
    }
    if (buf.length < 2 || (encoding && !encoding.startsWith('utf')))
        return buf.toString(encoding);
    const bom = (buf[0] << 8) | buf[1];
    if (bom === BOM_BE || (buf[0] === 0 && buf[1] !== 0))
        return decodeUtf16BE(buf);
    if (bom === BOM_LE || (buf[0] !== 0 && buf[1] === 0))
        return decodeUtf16LE(buf);
    return buf.toString(encoding);
}
exports.decode = decode;
function swapBytesInPlace(data) {
    const buf = (0, arrayBuffers_js_1.arrayBufferViewToBuffer)(data);
    buf.swap16();
    return buf;
}
exports.swapBytesInPlace = swapBytesInPlace;
function swapBytes(data) {
    const buf = (0, arrayBuffers_js_1.copyArrayBufferView)(data);
    return swapBytesInPlace(buf);
}
exports.swapBytes = swapBytes;
function encodeString(str, encoding, bom) {
    switch (encoding) {
        case 'utf16be':
            return encodeUtf16BE(str, bom);
        case 'utf16le':
            return encodeUtf16LE(str, bom);
    }
    return Buffer.from(str, encoding);
}
exports.encodeString = encodeString;
function encodeUtf16LE(str, bom = true) {
    const buf = Buffer.from(str, 'utf16le');
    if (bom) {
        const target = Buffer.alloc(buf.length + 2);
        target.writeUint16LE(BOM_BE);
        buf.copy(target, 2);
        return target;
    }
    return buf;
}
exports.encodeUtf16LE = encodeUtf16LE;
function encodeUtf16BE(str, bom = true) {
    return swapBytesInPlace(encodeUtf16LE(str, bom));
}
exports.encodeUtf16BE = encodeUtf16BE;
function calcEncodingFromBom(data) {
    const buf = (0, arrayBuffers_js_1.toUint8Array)(data);
    if (buf.length < 2)
        return undefined;
    switch ((buf[0] << 8) | buf[1]) {
        case BOM_BE:
            return 'utf16be';
        case BOM_LE:
            return 'utf16le';
    }
    return undefined;
}
exports.calcEncodingFromBom = calcEncodingFromBom;
//# sourceMappingURL=encode-decode.js.map