"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sliceView = exports.copyArrayBufferView = exports.arrayBufferViewToBuffer = exports.toUint8Array = void 0;
function toUint8Array(data) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
}
exports.toUint8Array = toUint8Array;
function arrayBufferViewToBuffer(data) {
    if (data instanceof Buffer) {
        return data;
    }
    const buf = Buffer.from(data.buffer);
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
        return buf;
    }
    return buf.subarray(data.byteOffset, data.byteOffset + data.byteLength);
}
exports.arrayBufferViewToBuffer = arrayBufferViewToBuffer;
/**
 * Copy the data buffer.
 * @param data - source data
 * @returns A copy of the data
 */
function copyArrayBufferView(data) {
    return new Uint8Array(data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength));
}
exports.copyArrayBufferView = copyArrayBufferView;
/**
 * Slice an existing data view. Returns a new view using the same underlying data.
 * @param data - data view
 * @param byteOffset - offset from the beginning of the view.
 * @param byteLength - optional length
 */
function sliceView(data, byteOffset, byteLength) {
    const currentEnd = data.byteOffset + data.byteLength;
    const start = Math.min(data.byteOffset + byteOffset, currentEnd);
    const end = byteLength ? Math.min(currentEnd, start + byteLength) : currentEnd;
    return {
        buffer: data.buffer,
        byteOffset: start,
        byteLength: end - start,
    };
}
exports.sliceView = sliceView;
//# sourceMappingURL=arrayBuffers.js.map